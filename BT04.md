# BT04: X√¢y d·ª±ng h·ªá th·ªëng Full-Stack v·ªõi Authentication

## üìã Y√™u c·∫ßu ƒë·ªÅ b√†i
- X√¢y d·ª±ng ·ª©ng d·ª•ng full-stack v·ªõi frontend React v√† backend Express
- Implement h·ªá th·ªëng authentication v·ªõi JWT (JSON Web Token)
- S·ª≠ d·ª•ng MySQL database v·ªõi Sequelize ORM
- Protected routes v·ªõi role-based access control
- T√≠ch h·ª£p frontend-backend v·ªõi Axios

## ‚úÖ Nh·ªØng g√¨ ƒë√£ th·ª±c hi·ªán

### üìç Project: `lab04_fullstack_react_express`

#### Tech Stack

**Backend:**
```json
{
  "express": "^4.18.2",              // Web framework
  "sequelize": "^6.34.0",            // MySQL ORM
  "mysql2": "^3.6.3",                // MySQL driver
  "jsonwebtoken": "^9.0.2",          // JWT authentication
  "bcryptjs": "^2.4.3",              // Password hashing
  "helmet": "^7.1.0",                // Security headers
  "cors": "^2.8.5",                  // CORS middleware
  "express-rate-limit": "^7.1.5",    // Rate limiting
  "express-validator": "^7.0.1",     // Input validation
  "multer": "^1.4.5-lts.1",          // File uploads
  "nodemailer": "^6.9.7"             // Email service
}
```

**Frontend:**
```json
{
  "react": "^18.2.0",                // UI library
  "react-router-dom": "^6.18.0",     // Client-side routing
  "axios": "^1.6.0",                 // HTTP client
  "react-hook-form": "^7.47.0",      // Form handling
  "@hookform/resolvers": "^3.3.2",   // Validation resolver
  "yup": "^1.3.3",                   // Schema validation
  "tailwindcss": "^3.4.18",          // CSS framework
  "react-hot-toast": "^2.6.0",       // Toast notifications
  "lucide-react": "^0.292.0",        // Icons
  "js-cookie": "^3.0.5"              // Cookie handling
}
```

#### C·∫•u tr√∫c d·ª± √°n
```
lab04_fullstack_react_express/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.js                 # Entry point
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.js           # Sequelize configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js              # Model associations
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.js               # User model
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Role.js               # Role model
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Position.js           # Position model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.js    # Auth logic (register, login, etc.)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.controller.js    # User CRUD
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js               # JWT verification
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation.js         # Input validation
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.js       # Error handling
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.routes.js        # Auth endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.routes.js        # User endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ seeders/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.js              # Database seeding
‚îÇ   ‚îî‚îÄ‚îÄ uploads/
‚îÇ       ‚îî‚îÄ‚îÄ avatars/                  # User avatars
‚îî‚îÄ‚îÄ frontend/
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ vite.config.js
    ‚îú‚îÄ‚îÄ tailwind.config.js
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ main.jsx                  # React entry
    ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx                   # Root component
    ‚îÇ   ‚îú‚îÄ‚îÄ contexts/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.jsx       # Authentication state
    ‚îÇ   ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.js                # Axios configuration
    ‚îÇ   ‚îú‚îÄ‚îÄ pages/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Login.jsx             # Login page
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Register.jsx          # Registration page
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.jsx         # Protected dashboard
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Profile.jsx           # User profile
    ‚îÇ   ‚îî‚îÄ‚îÄ components/
    ‚îÇ       ‚îú‚îÄ‚îÄ PrivateRoute.jsx      # Route protection
    ‚îÇ       ‚îî‚îÄ‚îÄ Navbar.jsx            # Navigation
    ‚îî‚îÄ‚îÄ public/
```

## üîß Chi ti·∫øt Implementation

### 1. Backend - Authentication System

#### JWT Token Generation
**üìç File:** `backend/src/controllers/auth.controller.js`

```javascript
const jwt = require('jsonwebtoken');

// Generate access token (15 minutes)
const generateToken = (userId) => {
    return jwt.sign(
        { id: userId }, 
        process.env.JWT_SECRET, 
        { expiresIn: '15m' }
    );
};

// Generate refresh token (7 days)
const generateRefreshToken = (userId) => {
    return jwt.sign(
        { id: userId }, 
        process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET, 
        { expiresIn: '7d' }
    );
};
```

#### Register Endpoint
```javascript
const register = async (req, res) => {
    try {
        const { firstName, lastName, email, password, roleId, positionId } = req.body;

        // Check if user exists
        const existingUser = await User.findOne({ where: { email } });
        if (existingUser) {
            return res.status(400).json({
                success: false,
                message: 'User with this email already exists'
            });
        }

        // Validate role and position
        if (roleId) {
            const role = await Role.findByPk(roleId);
            if (!role || !role.isActive) {
                return res.status(400).json({
                    success: false,
                    message: 'Invalid role selected'
                });
            }
        }

        // Create user (password auto-hashed in model hook)
        const user = await User.create({
            firstName,
            lastName,
            email,
            password,
            roleId: roleId || null,
            positionId: positionId || null
        });

        // Generate JWT token
        const token = generateToken(user.id);

        // Return user with associations
        const userWithDetails = await User.findByPk(user.id, {
            include: [
                { model: Role, as: 'role' },
                { model: Position, as: 'position' }
            ]
        });

        res.status(201).json({
            success: true,
            message: 'User registered successfully',
            data: {
                user: userWithDetails,
                token
            }
        });
    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({
            success: false,
            message: 'Registration failed',
            error: error.message
        });
    }
};
```

#### Authentication Middleware
**üìç File:** `backend/src/middleware/auth.js`

```javascript
const jwt = require('jsonwebtoken');
const { User, Role, Position } = require('../models');

// Verify JWT token
const authMiddleware = async (req, res, next) => {
    try {
        // Extract token from Authorization header
        const token = req.header('Authorization')?.replace('Bearer ', '');

        if (!token) {
            return res.status(401).json({
                success: false,
                message: 'Access denied. No token provided.'
            });
        }

        // Verify token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // Fetch user from database
        const user = await User.findByPk(decoded.id, {
            include: [
                { model: Role, as: 'role' },
                { model: Position, as: 'position' }
            ]
        });

        if (!user || !user.isActive) {
            return res.status(401).json({
                success: false,
                message: 'Invalid token or user deactivated.'
            });
        }

        // Attach user to request
        req.user = user;
        next();
    } catch (error) {
        console.error('Auth middleware error:', error);
        return res.status(401).json({
            success: false,
            message: 'Invalid token.'
        });
    }
};

// Admin-only middleware
const adminMiddleware = (req, res, next) => {
    if (!req.user) {
        return res.status(401).json({
            success: false,
            message: 'Authentication required.'
        });
    }

    if (!req.user.role || req.user.role.name !== 'Admin') {
        return res.status(403).json({
            success: false,
            message: 'Admin access required.'
        });
    }

    next();
};
```

#### Protected Routes
**üìç File:** `backend/src/routes/user.routes.js`

```javascript
const express = require('express');
const router = express.Router();
const userController = require('../controllers/user.controller');
const { authMiddleware, adminMiddleware } = require('../middleware/auth');

// Protected routes (require authentication)
router.get('/profile', authMiddleware, userController.getProfile);
router.put('/profile', authMiddleware, userController.updateProfile);

// Admin-only routes
router.get('/', authMiddleware, adminMiddleware, userController.getAllUsers);
router.delete('/:id', authMiddleware, adminMiddleware, userController.deleteUser);

module.exports = router;
```

### 2. Database Models (Sequelize)

#### User Model v·ªõi Password Hashing
**üìç File:** `backend/src/models/User.js`

```javascript
const { DataTypes } = require('sequelize');
const bcrypt = require('bcryptjs');

module.exports = (sequelize) => {
    const User = sequelize.define('User', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        firstName: {
            type: DataTypes.STRING,
            allowNull: false
        },
        lastName: {
            type: DataTypes.STRING,
            allowNull: false
        },
        email: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
            validate: {
                isEmail: true
            }
        },
        password: {
            type: DataTypes.STRING,
            allowNull: false
        },
        phone: DataTypes.STRING,
        avatar: DataTypes.STRING,
        isActive: {
            type: DataTypes.BOOLEAN,
            defaultValue: true
        },
        roleId: DataTypes.INTEGER,
        positionId: DataTypes.INTEGER
    }, {
        tableName: 'users',
        timestamps: true
    });

    // Hook: Hash password before saving
    User.beforeCreate(async (user) => {
        if (user.password) {
            const salt = await bcrypt.genSalt(10);
            user.password = await bcrypt.hash(user.password, salt);
        }
    });

    User.beforeUpdate(async (user) => {
        if (user.changed('password')) {
            const salt = await bcrypt.genSalt(10);
            user.password = await bcrypt.hash(user.password, salt);
        }
    });

    // Instance method: Compare password
    User.prototype.comparePassword = async function(candidatePassword) {
        return await bcrypt.compare(candidatePassword, this.password);
    };

    return User;
};
```

#### Model Associations
**üìç File:** `backend/src/models/index.js`

```javascript
const { Sequelize } = require('sequelize');
const sequelize = require('../config/database');

// Import models
const User = require('./User')(sequelize);
const Role = require('./Role')(sequelize);
const Position = require('./Position')(sequelize);

// Define associations
User.belongsTo(Role, { foreignKey: 'roleId', as: 'role' });
Role.hasMany(User, { foreignKey: 'roleId', as: 'users' });

User.belongsTo(Position, { foreignKey: 'positionId', as: 'position' });
Position.hasMany(User, { foreignKey: 'positionId', as: 'users' });

module.exports = {
    sequelize,
    User,
    Role,
    Position
};
```

### 3. Frontend - React Authentication

#### Axios Configuration v·ªõi Interceptors
**üìç File:** `frontend/src/services/api.js`

```javascript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5001/api';

// Create axios instance
const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json'
    }
});

// Request interceptor: Add JWT token
api.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// Response interceptor: Handle errors
api.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // Token expired or invalid
            localStorage.removeItem('token');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

// Auth API endpoints
export const authAPI = {
    register: (userData) => api.post('/auth/register', userData),
    login: (credentials) => api.post('/auth/login', credentials),
    getProfile: () => api.get('/auth/profile'),
    logout: () => api.post('/auth/logout')
};

// User API endpoints
export const userAPI = {
    getAll: () => api.get('/users'),
    getById: (id) => api.get(`/users/${id}`),
    update: (id, data) => api.put(`/users/${id}`, data),
    delete: (id) => api.delete(`/users/${id}`)
};

export default api;
```

#### Auth Context (Global State)
**üìç File:** `frontend/src/contexts/AuthContext.jsx`

```jsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { authAPI } from '../services/api';
import toast from 'react-hot-toast';

const AuthContext = createContext();

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [isLoading, setIsLoading] = useState(true);

    // Initialize auth on mount
    useEffect(() => {
        const initializeAuth = async () => {
            const token = localStorage.getItem('token');

            if (token) {
                try {
                    const response = await authAPI.getProfile();
                    if (response.data.success) {
                        setUser(response.data.data.user);
                    } else {
                        localStorage.removeItem('token');
                    }
                } catch (error) {
                    console.error('Token validation failed:', error);
                    localStorage.removeItem('token');
                }
            }

            setIsLoading(false);
        };

        initializeAuth();
    }, []);

    // Login function
    const login = async (email, password) => {
        try {
            const response = await authAPI.login({ email, password });
            
            if (response.data.success) {
                const { token, user } = response.data.data;
                localStorage.setItem('token', token);
                setUser(user);
                toast.success('Login successful!');
                return true;
            }
        } catch (error) {
            toast.error(error.response?.data?.message || 'Login failed');
            return false;
        }
    };

    // Logout function
    const logout = () => {
        localStorage.removeItem('token');
        setUser(null);
        toast.success('Logged out successfully');
    };

    // Register function
    const register = async (userData) => {
        try {
            const response = await authAPI.register(userData);
            
            if (response.data.success) {
                const { token, user } = response.data.data;
                localStorage.setItem('token', token);
                setUser(user);
                toast.success('Registration successful!');
                return true;
            }
        } catch (error) {
            toast.error(error.response?.data?.message || 'Registration failed');
            return false;
        }
    };

    const value = {
        user,
        isLoading,
        login,
        logout,
        register,
        isAuthenticated: !!user
    };

    return (
        <AuthContext.Provider value={value}>
            {children}
        </AuthContext.Provider>
    );
};
```

#### Protected Route Component
**üìç File:** `frontend/src/components/PrivateRoute.jsx`

```jsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

const PrivateRoute = ({ children, requiredRole }) => {
    const { user, isLoading, isAuthenticated } = useAuth();

    if (isLoading) {
        return <div>Loading...</div>;
    }

    if (!isAuthenticated) {
        return <Navigate to="/login" replace />;
    }

    // Role-based access control
    if (requiredRole && user.role?.name !== requiredRole) {
        return <Navigate to="/unauthorized" replace />;
    }

    return children;
};

export default PrivateRoute;
```

#### App Router v·ªõi Protected Routes
**üìç File:** `frontend/src/App.jsx`

```jsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import PrivateRoute from './components/PrivateRoute';
import Login from './pages/Login';
import Register from './pages/Register';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';
import AdminPanel from './pages/AdminPanel';

function App() {
    return (
        <AuthProvider>
            <Router>
                <Routes>
                    {/* Public routes */}
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />

                    {/* Protected routes */}
                    <Route 
                        path="/dashboard" 
                        element={
                            <PrivateRoute>
                                <Dashboard />
                            </PrivateRoute>
                        } 
                    />
                    <Route 
                        path="/profile" 
                        element={
                            <PrivateRoute>
                                <Profile />
                            </PrivateRoute>
                        } 
                    />

                    {/* Admin-only route */}
                    <Route 
                        path="/admin" 
                        element={
                            <PrivateRoute requiredRole="Admin">
                                <AdminPanel />
                            </PrivateRoute>
                        } 
                    />
                </Routes>
            </Router>
        </AuthProvider>
    );
}

export default App;
```

## üîç C∆° ch·∫ø ho·∫°t ƒë·ªông

### 1. Authentication Flow
```
User Login
    ‚Üì
Frontend: POST /api/auth/login { email, password }
    ‚Üì
Backend: Validate credentials
    ‚Üì
Backend: Generate JWT token
    ‚Üì
Backend: Return { token, user }
    ‚Üì
Frontend: Store token in localStorage
    ‚Üì
Frontend: Set user in AuthContext
    ‚Üì
Frontend: Redirect to dashboard
```

### 2. Protected API Request Flow
```
Frontend: API request (e.g., GET /api/users)
    ‚Üì
Axios Interceptor: Add Authorization header
    Headers: { Authorization: "Bearer <token>" }
    ‚Üì
Backend: authMiddleware extracts token
    ‚Üì
Backend: jwt.verify(token, JWT_SECRET)
    ‚Üì
Backend: Fetch user from database
    ‚Üì
Backend: Attach user to req.user
    ‚Üì
Backend: Controller processes request
    ‚Üì
Backend: Return response
    ‚Üì
Frontend: Handle response data
```

### 3. Token Expiration Handling
```
Frontend: Makes API request
    ‚Üì
Backend: Token expired (401 error)
    ‚Üì
Axios Response Interceptor: Catch 401
    ‚Üì
Frontend: Remove token from localStorage
    ‚Üì
Frontend: Redirect to /login
    ‚Üì
User logs in again
    ‚Üì
New token generated
```

### 4. Role-Based Access Control
```
User requests admin page (/admin)
    ‚Üì
PrivateRoute: Check if authenticated
    ‚Üì
PrivateRoute: Check if user.role === "Admin"
    ‚Üì
If Admin: Render AdminPanel
If Not Admin: Navigate to /unauthorized
```

## üí° V√≠ d·ª• c·ª• th·ªÉ

### V√≠ d·ª• 1: Login Flow ho√†n ch·ªânh
```jsx
// Login.jsx
const handleLogin = async (e) => {
    e.preventDefault();
    const success = await login(email, password);
    
    if (success) {
        navigate('/dashboard'); // Redirect after login
    }
};

// Behind the scenes:
// 1. AuthContext.login() calls authAPI.login()
// 2. axios POST to /api/auth/login
// 3. Backend validates credentials
// 4. Backend returns { token, user }
// 5. Frontend stores token in localStorage
// 6. Frontend sets user in AuthContext state
// 7. All child components can access user via useAuth()
```

### V√≠ d·ª• 2: Protected API Call
```jsx
// Dashboard.jsx
useEffect(() => {
    const fetchDashboardData = async () => {
        try {
            // Axios automatically adds Authorization header
            const response = await api.get('/dashboard/stats');
            setData(response.data.data);
        } catch (error) {
            // If 401, axios interceptor redirects to login
            console.error('Failed to fetch data:', error);
        }
    };

    fetchDashboardData();
}, []);
```

### V√≠ d·ª• 3: Role-Based UI Rendering
```jsx
// Navbar.jsx
import { useAuth } from '../contexts/AuthContext';

const Navbar = () => {
    const { user, logout } = useAuth();

    return (
        <nav>
            <Link to="/dashboard">Dashboard</Link>
            
            {/* Admin-only link */}
            {user?.role?.name === 'Admin' && (
                <Link to="/admin">Admin Panel</Link>
            )}
            
            <button onClick={logout}>Logout</button>
        </nav>
    );
};
```

## üìä Security Features

| Feature | Implementation | Purpose |
|---------|---------------|---------|
| JWT Authentication | jsonwebtoken | Stateless authentication |
| Password Hashing | bcryptjs with salt | Secure password storage |
| CORS | cors middleware | Cross-origin protection |
| Helmet | helmet middleware | Security HTTP headers |
| Rate Limiting | express-rate-limit | Brute force protection |
| Input Validation | express-validator | Prevent injection attacks |
| Token Expiration | 15min access + 7day refresh | Minimize token exposure |
| HTTPS | (production) | Encrypt data in transit |

## üéØ K·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c

| Ti√™u ch√≠ | Tr·∫°ng th√°i | Ghi ch√∫ |
|----------|-----------|---------|
| JWT Authentication | ‚úÖ Ho√†n th√†nh | Access + Refresh tokens |
| Protected Routes (Backend) | ‚úÖ Ho√†n th√†nh | authMiddleware, adminMiddleware |
| Protected Routes (Frontend) | ‚úÖ Ho√†n th√†nh | PrivateRoute component |
| Role-Based Access Control | ‚úÖ Ho√†n th√†nh | Admin, User roles |
| Axios Integration | ‚úÖ Ho√†n th√†nh | Interceptors for auth |
| Auth Context (React) | ‚úÖ Ho√†n th√†nh | Global state management |
| Password Security | ‚úÖ Ho√†n th√†nh | bcrypt hashing |
| MySQL + Sequelize | ‚úÖ Ho√†n th√†nh | User, Role, Position models |
| Form Validation | ‚úÖ Ho√†n th√†nh | react-hook-form + yup |
| Error Handling | ‚úÖ Ho√†n th√†nh | Toast notifications |

## üöÄ L·ªánh ch·∫°y project

```bash
# Backend
cd lab04_fullstack_react_express/backend
npm install
npm run seed    # Seed database
npm run dev     # Run on port 5001

# Frontend (new terminal)
cd lab04_fullstack_react_express/frontend
npm install
npm run dev     # Run on port 3000
```

**Environment Variables (.env):**
```env
# Backend
PORT=5001
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=lab04_fullstack
JWT_SECRET=your_jwt_secret_key
JWT_REFRESH_SECRET=your_refresh_secret_key

# Frontend
VITE_API_URL=http://localhost:5001/api
```

## üìö ƒêi·ªÉm m·∫°nh c·ªßa implementation

1. **Separation of Concerns**: Backend v√† frontend ho√†n to√†n t√°ch bi·ªát
2. **RESTful API**: Chu·∫©n REST conventions
3. **JWT Authentication**: Stateless, scalable authentication
4. **Context API**: Global state management kh√¥ng c·∫ßn Redux
5. **Axios Interceptors**: Automatic token injection v√† error handling
6. **Protected Routes**: Both server-side v√† client-side protection
7. **Role-Based Access Control**: Fine-grained permissions
8. **Security Best Practices**: Helmet, rate limiting, input validation
9. **Modern React**: Hooks, functional components
10. **Tailwind CSS**: Utility-first styling

---

**Ng√†y ho√†n th√†nh:** Th√°ng 11/2024  
**Sinh vi√™n th·ª±c hi·ªán:** Hu·ª≥nh Thanh Duy - 22110118
