# BT08 - User Engagement Features (PH·∫¶N 1: Backend)

## üìã Y√™u c·∫ßu ƒë·ªÅ b√†i

**BT08**: X√¢y d·ª±ng h·ªá th·ªëng engagement features ƒë·ªÉ tƒÉng t∆∞∆°ng t√°c ng∆∞·ªùi d√πng v·ªõi apartment marketplace, bao g·ªìm: Favorites (y√™u th√≠ch), Reviews (ƒë√°nh gi√°), Views (l∆∞·ª£t xem), Statistics (th·ªëng k√™), v√† Similar Apartments (g·ª£i √Ω cƒÉn h·ªô t∆∞∆°ng t·ª±).

**M·ª•c ti√™u**:
- Cho ph√©p users bookmark apartments y√™u th√≠ch
- H·ªá th·ªëng ƒë√°nh gi√° 5 sao v·ªõi comments
- Tracking l∆∞·ª£t xem apartments (c·∫£ authenticated v√† guest users)
- Dashboard th·ªëng k√™ engagement metrics
- Recommendation engine cho similar apartments
- TƒÉng user retention v√† time-on-site

## üõ†Ô∏è Tech Stack (Backend)

| Technology | Version | M·ª•c ƒë√≠ch |
|-----------|---------|----------|
| Sequelize | 6.34.0 | ORM for database operations |
| MySQL | 8.0+ | Primary database |
| Express.js | 5.0.1 | REST API framework |
| express-validator | 7.0.1 | Input validation |
| Sequelize Operators | - | Complex queries (Op.between, Op.gte, etc.) |
| Sequelize Functions | - | Aggregations (COUNT, AVG) |

## üìÅ C·∫•u tr√∫c Backend

```
lab05_ManageBuilding/backend/src/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ ApartmentFavorite.js      # Favorites model
‚îÇ   ‚îú‚îÄ‚îÄ ApartmentReview.js        # Reviews model (1-5 stars + comment)
‚îÇ   ‚îú‚îÄ‚îÄ ApartmentView.js          # View tracking model
‚îÇ   ‚îî‚îÄ‚îÄ index.js                  # Model associations
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ favorite.controller.js    # Favorite CRUD operations
‚îÇ   ‚îú‚îÄ‚îÄ review.controller.js      # Review CRUD with tenant validation
‚îÇ   ‚îî‚îÄ‚îÄ view.controller.js        # View tracking & recently viewed
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ apartment.stats.service.js # Statistics calculations
‚îÇ   ‚îî‚îÄ‚îÄ apartment.service.js      # Similar apartments algorithm
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ favorite.routes.js        # /api/favorites/*
    ‚îú‚îÄ‚îÄ review.routes.js          # /api/reviews/*
    ‚îî‚îÄ‚îÄ apartment.routes.js       # /api/apartments/:id/similar
```

## üéØ Chi ti·∫øt Implementation - Backend

### 1. Database Models

#### 1.1 ApartmentFavorite Model

```javascript
// models/ApartmentFavorite.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const ApartmentFavorite = sequelize.define('ApartmentFavorite', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    userId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: 'Users',
            key: 'id'
        },
        onDelete: 'CASCADE'
    },
    apartmentId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: 'apartments',
            key: 'id'
        },
        onDelete: 'CASCADE'
    }
}, {
    tableName: 'apartment_favorites',
    timestamps: true,
    updatedAt: false,  // Only track createdAt (when favorited)
    indexes: [
        {
            unique: true,
            fields: ['user_id', 'apartment_id'],
            name: 'unique_user_apartment_favorite'  // Prevent duplicate favorites
        },
        {
            fields: ['user_id']  // Fast user favorites lookup
        },
        {
            fields: ['apartment_id']  // Fast apartment favorites count
        }
    ]
});

module.exports = ApartmentFavorite;
```

**ƒê·∫∑c ƒëi·ªÉm**:
- **Unique constraint**: M·ªói user ch·ªâ favorite 1 apartment 1 l·∫ßn
- **Cascade delete**: T·ª± ƒë·ªông x√≥a favorites khi user ho·∫∑c apartment b·ªã x√≥a
- **No updatedAt**: Ch·ªâ c·∫ßn bi·∫øt khi n√†o favorite (createdAt)
- **Indexes**: Optimize queries cho user favorites v√† apartment favorite count

#### 1.2 ApartmentReview Model

```javascript
// models/ApartmentReview.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const ApartmentReview = sequelize.define('ApartmentReview', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    apartmentId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: 'apartments',
            key: 'id'
        },
        onDelete: 'CASCADE'
    },
    userId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: 'Users',
            key: 'id'
        },
        onDelete: 'CASCADE'
    },
    rating: {
        type: DataTypes.INTEGER,
        allowNull: false,
        validate: {
            min: 1,
            max: 5,
            isInt: true
        },
        comment: 'Rating from 1 to 5 stars'
    },
    comment: {
        type: DataTypes.TEXT,
        allowNull: true,
        validate: {
            len: [0, 2000]  // Max 2000 characters
        }
    }
}, {
    tableName: 'apartment_reviews',
    timestamps: true,  // Track createdAt and updatedAt
    indexes: [
        {
            unique: true,
            fields: ['user_id', 'apartment_id'],
            name: 'unique_user_apartment_review'  // One review per user per apartment
        },
        {
            fields: ['apartment_id']  // Fast apartment reviews lookup
        },
        {
            fields: ['user_id']  // Fast user reviews lookup
        },
        {
            fields: ['rating']  // Fast rating aggregation queries
        }
    ]
});

module.exports = ApartmentReview;
```

**ƒê·∫∑c ƒëi·ªÉm**:
- **Rating validation**: Enforce 1-5 star range t·∫°i database level
- **Comment length limit**: Max 2000 characters
- **Unique constraint**: M·ªói user ch·ªâ review 1 apartment 1 l·∫ßn (c√≥ th·ªÉ update)
- **Full timestamps**: Track c·∫£ createdAt v√† updatedAt cho edit history

#### 1.3 ApartmentView Model

```javascript
// models/ApartmentView.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const ApartmentView = sequelize.define('ApartmentView', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    userId: {
        type: DataTypes.INTEGER,
        allowNull: true,  // NULL for guest views
        references: {
            model: 'Users',
            key: 'id'
        },
        onDelete: 'SET NULL',  // Keep view data even if user deleted
        comment: 'Nullable for guest views'
    },
    apartmentId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: 'apartments',
            key: 'id'
        },
        onDelete: 'CASCADE'
    },
    viewedAt: {
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    ipAddress: {
        type: DataTypes.STRING(45),  // Support both IPv4 and IPv6
        allowNull: true,
        comment: 'IPv4 or IPv6 address for guest tracking'
    }
}, {
    tableName: 'apartment_views',
    timestamps: false,  // Use viewedAt instead
    indexes: [
        {
            fields: ['user_id', 'viewed_at']  // Recently viewed by user
        },
        {
            fields: ['apartment_id']  // View count per apartment
        },
        {
            fields: ['ip_address', 'apartment_id', 'viewed_at']  // Guest deduplication
        }
    ]
});

module.exports = ApartmentView;
```

**ƒê·∫∑c ƒëi·ªÉm**:
- **Guest tracking**: userId nullable, s·ª≠ d·ª•ng ipAddress cho guests
- **View deduplication**: Prevent counting multiple views t·ª´ same user/IP trong 1 gi·ªù
- **SET NULL on delete**: Gi·ªØ view statistics khi user b·ªã x√≥a
- **IPv6 support**: STRING(45) accommodate c·∫£ IPv4 v√† IPv6 addresses

### 2. Controllers

#### 2.1 Favorite Controller

```javascript
// controllers/favorite.controller.js
const { ApartmentFavorite, Apartment, Floor, Building, Block } = require('../models');

// Add apartment to favorites
const addFavorite = async (req, res) => {
    try {
        const userId = req.user.id;
        const apartmentId = parseInt(req.params.apartmentId);

        // Check if apartment exists
        const apartment = await Apartment.findByPk(apartmentId);
        if (!apartment) {
            return res.status(404).json({
                success: false,
                message: 'Apartment not found'
            });
        }

        // Check if already favorited
        const existing = await ApartmentFavorite.findOne({
            where: { userId, apartmentId }
        });

        if (existing) {
            return res.status(200).json({
                success: true,
                message: 'Apartment already in favorites',
                isFavorite: true
            });
        }

        // Create favorite
        await ApartmentFavorite.create({ userId, apartmentId });

        res.status(201).json({
            success: true,
            message: 'Added to favorites',
            isFavorite: true
        });
    } catch (error) {
        console.error('Error adding favorite:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to add favorite',
            error: error.message
        });
    }
};

// Remove apartment from favorites
const removeFavorite = async (req, res) => {
    try {
        const userId = req.user.id;
        const apartmentId = parseInt(req.params.apartmentId);

        const deleted = await ApartmentFavorite.destroy({
            where: { userId, apartmentId }
        });

        if (deleted === 0) {
            return res.status(404).json({
                success: false,
                message: 'Favorite not found'
            });
        }

        res.status(200).json({
            success: true,
            message: 'Removed from favorites',
            isFavorite: false
        });
    } catch (error) {
        console.error('Error removing favorite:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to remove favorite',
            error: error.message
        });
    }
};

// Get all favorites for current user
const getFavorites = async (req, res) => {
    try {
        const userId = req.user.id;
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 20;
        const offset = (page - 1) * limit;

        const { count, rows: favorites } = await ApartmentFavorite.findAndCountAll({
            where: { userId },
            include: [
                {
                    model: Apartment,
                    as: 'apartment',
                    include: [
                        {
                            model: Floor,
                            as: 'floor',
                            attributes: ['id', 'floorNumber'],
                            include: [
                                {
                                    model: Building,
                                    as: 'building',
                                    attributes: ['id', 'name', 'address'],
                                    include: [
                                        {
                                            model: Block,
                                            as: 'block',
                                            attributes: ['id', 'name']
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ],
            order: [['createdAt', 'DESC']],
            limit,
            offset
        });

        const formattedFavorites = favorites.map(fav => ({
            id: fav.id,
            apartmentId: fav.apartmentId,
            favoritedAt: fav.createdAt,
            apartment: {
                id: fav.apartment.id,
                apartmentNumber: fav.apartment.apartmentNumber,
                type: fav.apartment.type,
                area: fav.apartment.area,
                bedrooms: fav.apartment.bedrooms,
                bathrooms: fav.apartment.bathrooms,
                monthlyRent: fav.apartment.monthlyRent,
                salePrice: fav.apartment.salePrice,
                status: fav.apartment.status,
                images: fav.apartment.images,
                block: fav.apartment.floor?.building?.block?.name,
                building: fav.apartment.floor?.building?.name,
                floor: fav.apartment.floor?.floorNumber
            }
        }));

        res.status(200).json({
            success: true,
            data: formattedFavorites,
            pagination: {
                total: count,
                page,
                limit,
                totalPages: Math.ceil(count / limit)
            }
        });
    } catch (error) {
        console.error('Error getting favorites:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get favorites',
            error: error.message
        });
    }
};

// Check if apartment is favorited by current user
const checkFavorite = async (req, res) => {
    try {
        const userId = req.user.id;
        const apartmentId = parseInt(req.params.apartmentId);

        const favorite = await ApartmentFavorite.findOne({
            where: { userId, apartmentId }
        });

        res.status(200).json({
            success: true,
            isFavorite: !!favorite
        });
    } catch (error) {
        console.error('Error checking favorite:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to check favorite',
            error: error.message
        });
    }
};

module.exports = {
    addFavorite,
    removeFavorite,
    getFavorites,
    checkFavorite
};
```

**Business logic highlights**:
- **Idempotent operations**: Add favorite multiple times returns success
- **Hierarchical data loading**: Include Block‚ÜíBuilding‚ÜíFloor associations
- **Pagination support**: Handle large favorite lists
- **Check endpoint**: Frontend c√≥ th·ªÉ check favorite status tr∆∞·ªõc khi render

#### 2.2 Review Controller

```javascript
// controllers/review.controller.js
const { ApartmentReview, Apartment, User } = require('../models');
const { validationResult } = require('express-validator');

// Create review (only for tenants/owners)
const createReview = async (req, res) => {
    try {
        // Validation
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({
                success: false,
                message: 'Validation failed',
                errors: errors.array()
            });
        }

        const userId = req.user.id;
        const apartmentId = parseInt(req.params.apartmentId);
        const { rating, comment } = req.body;

        // Check if apartment exists
        const apartment = await Apartment.findByPk(apartmentId);
        if (!apartment) {
            return res.status(404).json({
                success: false,
                message: 'Apartment not found'
            });
        }

        // Check if user is tenant or owner of this apartment
        const isTenantOrOwner = apartment.tenantId === userId || 
                                apartment.ownerId === userId;

        if (!isTenantOrOwner) {
            return res.status(403).json({
                success: false,
                message: 'Only tenants or owners can review this apartment'
            });
        }

        // Check if user already reviewed
        const existingReview = await ApartmentReview.findOne({
            where: { userId, apartmentId }
        });

        if (existingReview) {
            return res.status(400).json({
                success: false,
                message: 'You have already reviewed this apartment. Use update instead.'
            });
        }

        // Create review
        const review = await ApartmentReview.create({
            userId,
            apartmentId,
            rating,
            comment
        });

        res.status(201).json({
            success: true,
            message: 'Review created successfully',
            data: review
        });
    } catch (error) {
        console.error('Error creating review:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to create review',
            error: error.message
        });
    }
};

// Update own review
const updateReview = async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({
                success: false,
                message: 'Validation failed',
                errors: errors.array()
            });
        }

        const userId = req.user.id;
        const reviewId = parseInt(req.params.reviewId);
        const { rating, comment } = req.body;

        const review = await ApartmentReview.findByPk(reviewId);
        if (!review) {
            return res.status(404).json({
                success: false,
                message: 'Review not found'
            });
        }

        // Check ownership
        if (review.userId !== userId) {
            return res.status(403).json({
                success: false,
                message: 'You can only update your own reviews'
            });
        }

        // Update review
        await review.update({ rating, comment });

        res.status(200).json({
            success: true,
            message: 'Review updated successfully',
            data: review
        });
    } catch (error) {
        console.error('Error updating review:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to update review',
            error: error.message
        });
    }
};

// Delete own review
const deleteReview = async (req, res) => {
    try {
        const userId = req.user.id;
        const reviewId = parseInt(req.params.reviewId);

        const review = await ApartmentReview.findByPk(reviewId);
        if (!review) {
            return res.status(404).json({
                success: false,
                message: 'Review not found'
            });
        }

        // Check ownership
        if (review.userId !== userId) {
            return res.status(403).json({
                success: false,
                message: 'You can only delete your own reviews'
            });
        }

        await review.destroy();

        res.status(200).json({
            success: true,
            message: 'Review deleted successfully'
        });
    } catch (error) {
        console.error('Error deleting review:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to delete review',
            error: error.message
        });
    }
};

// Get reviews for an apartment
const getApartmentReviews = async (req, res) => {
    try {
        const apartmentId = parseInt(req.params.apartmentId);
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const offset = (page - 1) * limit;

        const { count, rows: reviews } = await ApartmentReview.findAndCountAll({
            where: { apartmentId },
            include: [
                {
                    model: User,
                    as: 'user',
                    attributes: ['id', 'fullName', 'avatar']
                }
            ],
            order: [['createdAt', 'DESC']],
            limit,
            offset
        });

        // Calculate average rating
        const { fn, col } = require('sequelize');
        const stats = await ApartmentReview.findOne({
            where: { apartmentId },
            attributes: [
                [fn('AVG', col('rating')), 'avgRating'],
                [fn('COUNT', col('id')), 'totalReviews']
            ],
            raw: true
        });

        res.status(200).json({
            success: true,
            data: {
                reviews,
                avgRating: parseFloat(stats?.avgRating || 0).toFixed(1),
                totalReviews: parseInt(stats?.totalReviews || 0)
            },
            pagination: {
                total: count,
                page,
                limit,
                totalPages: Math.ceil(count / limit)
            }
        });
    } catch (error) {
        console.error('Error getting reviews:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get reviews',
            error: error.message
        });
    }
};

module.exports = {
    createReview,
    updateReview,
    deleteReview,
    getApartmentReviews
};
```

**Authorization highlights**:
- **Tenant/owner validation**: Ch·ªâ tenant ho·∫∑c owner c·ªßa apartment m·ªõi review ƒë∆∞·ª£c
- **Ownership check**: User ch·ªâ update/delete review c·ªßa ch√≠nh h·ªç
- **express-validator**: Input validation cho rating (1-5) v√† comment length
- **Aggregation queries**: Calculate avg rating v√† total reviews real-time

#### 2.3 View Tracking Controller

```javascript
// controllers/view.controller.js
const { ApartmentView, Apartment, Floor, Building, Block } = require('../models');
const { Op } = require('sequelize');

// Track apartment view
const trackView = async (req, res) => {
    try {
        const apartmentId = parseInt(req.params.apartmentId);
        const userId = req.user?.id || null;  // Null for guests
        const ipAddress = req.ip || req.connection.remoteAddress;

        // Check if apartment exists
        const apartment = await Apartment.findByPk(apartmentId);
        if (!apartment) {
            return res.status(404).json({
                success: false,
                message: 'Apartment not found'
            });
        }

        // Deduplicate views within 1 hour
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

        const existingView = await ApartmentView.findOne({
            where: {
                apartmentId,
                ...(userId ? { userId } : { ipAddress, userId: null }),
                viewedAt: {
                    [Op.gte]: oneHourAgo
                }
            }
        });

        if (existingView) {
            // Update viewedAt to current time
            await existingView.update({ viewedAt: new Date() });
            return res.status(200).json({
                success: true,
                message: 'View updated',
                viewId: existingView.id
            });
        }

        // Create new view record
        const view = await ApartmentView.create({
            userId,
            apartmentId,
            ipAddress: userId ? null : ipAddress,
            viewedAt: new Date()
        });

        res.status(201).json({
            success: true,
            message: 'View tracked',
            viewId: view.id
        });
    } catch (error) {
        console.error('Error tracking view:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to track view',
            error: error.message
        });
    }
};

// Get recently viewed apartments for user
const getRecentlyViewed = async (req, res) => {
    try {
        const userId = req.user.id;
        const limit = parseInt(req.query.limit) || 20;

        const views = await ApartmentView.findAll({
            where: { userId },
            include: [
                {
                    model: Apartment,
                    as: 'apartment',
                    include: [
                        {
                            model: Floor,
                            as: 'floor',
                            include: [
                                {
                                    model: Building,
                                    as: 'building',
                                    include: [
                                        {
                                            model: Block,
                                            as: 'block'
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ],
            order: [['viewedAt', 'DESC']],
            limit,
            // Deduplicate - only latest view per apartment
            distinct: true,
            group: ['apartmentId']
        });

        res.status(200).json({
            success: true,
            data: views
        });
    } catch (error) {
        console.error('Error getting recently viewed:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get recently viewed',
            error: error.message
        });
    }
};

module.exports = {
    trackView,
    getRecentlyViewed
};
```

**View tracking highlights**:
- **Guest support**: Track views c·∫£ cho authenticated users v√† guests (via IP)
- **Deduplication**: Ch·ªâ count 1 view per user/IP trong 1 gi·ªù
- **Auto-update**: Update viewedAt n·∫øu view trong timeframe
- **Recently viewed**: Get latest view per apartment (distinct)

### 3. Services

#### 3.1 Apartment Statistics Service

```javascript
// services/apartment.stats.service.js
const { HouseholdMember, ApartmentReview, ApartmentView, ApartmentFavorite } = require('../models');
const { fn, col } = require('sequelize');

/**
 * Get comprehensive statistics for an apartment
 */
const getApartmentStats = async (apartmentId) => {
    try {
        // Count buyers (household members who are tenants or owners)
        const buyerCount = await HouseholdMember.count({
            where: {
                apartmentId,
                isActive: true
            }
        });

        // Get review statistics
        const reviewStats = await ApartmentReview.findOne({
            where: { apartmentId },
            attributes: [
                [fn('COUNT', col('id')), 'reviewCount'],
                [fn('AVG', col('rating')), 'avgRating']
            ],
            raw: true
        });

        const reviewCount = parseInt(reviewStats?.reviewCount || 0);
        const avgRating = reviewStats?.avgRating 
            ? parseFloat(reviewStats.avgRating).toFixed(1) 
            : 0;

        // Count total views
        const viewCount = await ApartmentView.count({
            where: { apartmentId }
        });

        // Count favorites
        const favoriteCount = await ApartmentFavorite.count({
            where: { apartmentId }
        });

        return {
            apartmentId,
            buyerCount,
            reviewCount,
            avgRating: parseFloat(avgRating),
            viewCount,
            favoriteCount
        };
    } catch (error) {
        console.error('Error getting apartment stats:', error);
        throw error;
    }
};

/**
 * Get statistics for multiple apartments (batch)
 */
const getBatchApartmentStats = async (apartmentIds) => {
    try {
        const statsMap = {};

        // Get buyer counts
        const buyerCounts = await HouseholdMember.findAll({
            where: {
                apartmentId: apartmentIds,
                isActive: true
            },
            attributes: [
                'apartmentId',
                [fn('COUNT', col('id')), 'count']
            ],
            group: ['apartmentId'],
            raw: true
        });

        // Get review stats
        const reviewStats = await ApartmentReview.findAll({
            where: { apartmentId: apartmentIds },
            attributes: [
                'apartmentId',
                [fn('COUNT', col('id')), 'reviewCount'],
                [fn('AVG', col('rating')), 'avgRating']
            ],
            group: ['apartmentId'],
            raw: true
        });

        // Get view counts
        const viewCounts = await ApartmentView.findAll({
            where: { apartmentId: apartmentIds },
            attributes: [
                'apartmentId',
                [fn('COUNT', col('id')), 'count']
            ],
            group: ['apartmentId'],
            raw: true
        });

        // Get favorite counts
        const favoriteCounts = await ApartmentFavorite.findAll({
            where: { apartmentId: apartmentIds },
            attributes: [
                'apartmentId',
                [fn('COUNT', col('id')), 'count']
            ],
            group: ['apartmentId'],
            raw: true
        });

        // Initialize stats for all apartments
        apartmentIds.forEach(id => {
            statsMap[id] = {
                apartmentId: id,
                buyerCount: 0,
                reviewCount: 0,
                avgRating: 0,
                viewCount: 0,
                favoriteCount: 0
            };
        });

        // Populate stats
        buyerCounts.forEach(item => {
            statsMap[item.apartmentId].buyerCount = parseInt(item.count);
        });

        reviewStats.forEach(item => {
            statsMap[item.apartmentId].reviewCount = parseInt(item.reviewCount);
            statsMap[item.apartmentId].avgRating = parseFloat(item.avgRating).toFixed(1);
        });

        viewCounts.forEach(item => {
            statsMap[item.apartmentId].viewCount = parseInt(item.count);
        });

        favoriteCounts.forEach(item => {
            statsMap[item.apartmentId].favoriteCount = parseInt(item.count);
        });

        return statsMap;
    } catch (error) {
        console.error('Error getting batch apartment stats:', error);
        throw error;
    }
};

module.exports = {
    getApartmentStats,
    getBatchApartmentStats
};
```

**Statistics service highlights**:
- **Comprehensive metrics**: Buyers, reviews, views, favorites in 1 call
- **Batch operations**: Efficient loading cho multiple apartments
- **Sequelize aggregations**: COUNT, AVG functions
- **Grouped queries**: GROUP BY apartmentId for batch stats

#### 3.2 Similar Apartments Algorithm

```javascript
// services/apartment.service.js
const { Apartment, Floor, Building, Block } = require('../models');
const { Op } = require('sequelize');

/**
 * Find similar apartments based on type, bedrooms, area, and price
 */
const getSimilarApartments = async (apartmentId, limit = 6) => {
    try {
        // Get the current apartment details
        const currentApartment = await Apartment.findByPk(apartmentId);
        if (!currentApartment) {
            throw new Error('Apartment not found');
        }

        const area = parseFloat(currentApartment.area);
        const areaMin = area * 0.8;  // -20%
        const areaMax = area * 1.2;  // +20%

        // Determine price and calculate range
        const price = currentApartment.isListedForSale
            ? parseFloat(currentApartment.salePrice)
            : parseFloat(currentApartment.monthlyRent);

        const priceMin = price * 0.7;  // -30%
        const priceMax = price * 1.3;  // +30%

        // Build where conditions for similar apartments
        const whereConditions = {
            id: { [Op.ne]: apartmentId },  // Exclude current apartment
            status: { [Op.in]: ['for_rent', 'for_sale'] },  // Only available
            [Op.or]: [
                { type: currentApartment.type },  // Same type
                { bedrooms: currentApartment.bedrooms }  // OR same bedrooms
            ],
            area: {
                [Op.between]: [areaMin, areaMax]
            }
        };

        // Add price condition based on listing type
        if (currentApartment.isListedForSale) {
            whereConditions.isListedForSale = true;
            whereConditions.salePrice = {
                [Op.between]: [priceMin, priceMax]
            };
        } else {
            whereConditions.isListedForRent = true;
            whereConditions.monthlyRent = {
                [Op.between]: [priceMin, priceMax]
            };
        }

        // Find similar apartments
        const similarApartments = await Apartment.findAll({
            where: whereConditions,
            include: [
                {
                    model: Floor,
                    as: 'floor',
                    include: [
                        {
                            model: Building,
                            as: 'building',
                            include: [
                                {
                                    model: Block,
                                    as: 'block'
                                }
                            ]
                        }
                    ]
                }
            ],
            limit: limit * 2,  // Get more to allow filtering
            order: [['createdAt', 'DESC']]
        });

        // Format and limit results
        const formattedApartments = similarApartments.slice(0, limit).map(apt => ({
            id: apt.id,
            code: apt.apartmentNumber,
            type: apt.type,
            area: parseFloat(apt.area),
            bedrooms: apt.bedrooms,
            bathrooms: apt.bathrooms,
            price: apt.isListedForSale 
                ? parseFloat(apt.salePrice) 
                : parseFloat(apt.monthlyRent),
            mode: apt.isListedForSale ? 'buy' : 'rent',
            status: apt.status,
            images: apt.images || [],
            block: apt.floor?.building?.block?.name || 'N/A',
            building: apt.floor?.building?.name || 'N/A',
            floor: apt.floor?.floorNumber || 'N/A'
        }));

        return formattedApartments;
    } catch (error) {
        console.error('Error getting similar apartments:', error);
        throw error;
    }
};

module.exports = {
    getSimilarApartments
};
```

**Recommendation algorithm**:
- **Multi-criteria matching**: Type, bedrooms, area, price
- **Flexible ranges**: ¬±20% area, ¬±30% price tolerance
- **OR logic**: Same type OR same bedrooms (more results)
- **Same listing type**: Rent v·ªõi rent, buy v·ªõi buy
- **Prioritize availability**: Ch·ªâ show for_rent/for_sale apartments

---

## ‚è∏Ô∏è K·∫æT TH√öC PH·∫¶N 1

Ph·∫ßn 1 n√†y ƒë√£ cover:
- ‚úÖ 3 Database models (Favorites, Reviews, Views)
- ‚úÖ 3 Controllers v·ªõi full CRUD operations
- ‚úÖ 2 Services (Statistics, Similar apartments)
- ‚úÖ Business logic v√† authorization rules

**TI·∫æP THEO - PH·∫¶N 2 s·∫Ω bao g·ªìm**:
- Frontend components (FavoriteButton, ReviewForm, ReviewList, ApartmentStats, SimilarApartments)
- Workflows v·ªõi Mermaid diagrams
- API usage examples
- Testing v·ªõi curl commands
- K·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c

B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c t·∫°o **BT08_PART2.md** ngay kh√¥ng? üöÄ
