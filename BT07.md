# BT07 - Reusable Component Library & GraphQL Integration

## ðŸ“‹ YÃªu cáº§u Ä‘á» bÃ i

**BT07**: Táº¡o má»™t reusable component library cho giá» hÃ ng (cart) vÃ  tÃ­ch há»£p GraphQL API Ä‘á»ƒ quáº£n lÃ½ cart operations má»™t cÃ¡ch hiá»‡u quáº£.

**Má»¥c tiÃªu**:
- XÃ¢y dá»±ng thÆ° viá»‡n React component Ä‘á»™c láº­p, cÃ³ thá»ƒ tÃ¡i sá»­ dá»¥ng
- TÃ­ch há»£p Apollo Server vá»›i GraphQL cho cart operations
- Há»— trá»£ cáº£ thuÃª (rent) vÃ  mua (buy) cÄƒn há»™
- Quáº£n lÃ½ state vá»›i custom React hooks
- Äá»“ng bá»™ dá»¯ liá»‡u vá»›i backend qua REST API vÃ  GraphQL

## ðŸ› ï¸ Tech Stack

### lab07_CartComponent (Component Library)
| Technology | Version | Má»¥c Ä‘Ã­ch |
|-----------|---------|----------|
| React | ^18.0.0 | UI components framework |
| react-dom | ^18.0.0 | React rendering |
| CSS | - | Vanilla CSS styling (no dependencies) |

### lab05_ManageBuilding (GraphQL Backend)
| Technology | Version | Má»¥c Ä‘Ã­ch |
|-----------|---------|----------|
| Apollo Server Express | 3.13.0 | GraphQL server framework |
| GraphQL | 16.12.0 | Query language for API |
| Express.js | 5.0.1 | Web framework |
| Sequelize | 6.34.0 | ORM for MySQL |
| MySQL | 8.0+ | Database |
| jsonwebtoken | 9.0.2 | JWT authentication |

## ðŸ“ Cáº¥u trÃºc dá»± Ã¡n

### lab07_CartComponent (Standalone Library)
```
lab07_CartComponent/
â”œâ”€â”€ package.json                    # Library metadata, peer dependencies
â”œâ”€â”€ README.md                       # Comprehensive documentation
â””â”€â”€ src/
    â”œâ”€â”€ index.js                    # Export all components & hooks
    â”œâ”€â”€ styles.css                  # Global styles for components
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ Button.jsx              # Reusable button (4 variants)
    â”‚   â”œâ”€â”€ TextInput.jsx           # Input component
    â”‚   â”œâ”€â”€ Card.jsx                # Container card component
    â”‚   â”œâ”€â”€ CartItemCard.jsx        # Cart item display (enhanced)
    â”‚   â”œâ”€â”€ CartSummary.jsx         # Cart summary with totals
    â”‚   â”œâ”€â”€ ApartmentDetailCard.jsx # Apartment details preview
    â”‚   â”œâ”€â”€ LeaseTermSelector.jsx   # Lease duration slider
    â”‚   â””â”€â”€ PaymentBreakdown.jsx    # Payment details breakdown
    â””â”€â”€ hooks/
        â””â”€â”€ useCart.js              # Custom cart state management hook
```

### lab05_ManageBuilding/backend (GraphQL Integration)
```
backend/src/
â”œâ”€â”€ server.js                       # Apollo Server setup & middleware
â”œâ”€â”€ graphql/
â”‚   â”œâ”€â”€ cart.schema.js              # GraphQL type definitions
â”‚   â””â”€â”€ cart.resolvers.js           # GraphQL resolvers (queries/mutations)
â”œâ”€â”€ services/
â”‚   â””â”€â”€ cart.service.js             # Business logic for cart operations
â”œâ”€â”€ models/
â”‚   â””â”€â”€ Cart.js                     # Cart Sequelize model
â””â”€â”€ routes/
    â””â”€â”€ cart.routes.js              # REST API endpoints (fallback)
```

## ðŸŽ¯ Chi tiáº¿t Implementation

### 1. Component Library Architecture (lab07_CartComponent)

#### 1.1 Package Structure
```json
// package.json
{
  "name": "lab07_cartcomponent",
  "version": "1.0.4",
  "description": "ThÆ° viá»‡n component React Ä‘áº§y Ä‘á»§ cho há»‡ thá»‘ng giá» hÃ ng thuÃª/mua cÄƒn há»™",
  "main": "src/index.js",
  "module": "src/index.js",
  "peerDependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  }
}
```

**Äáº·c Ä‘iá»ƒm**:
- **Standalone library**: KhÃ´ng phá»¥ thuá»™c vÃ o external dependencies (ngoÃ i React)
- **Peer dependencies**: YÃªu cáº§u React 18+ tá»« host project
- **Module format**: ES6 modules cho tree-shaking optimization

#### 1.2 Core Components

**Button Component** (`Button.jsx`)
```jsx
const Button = ({ 
  variant = 'primary',  // primary, secondary, danger, ghost
  size = 'md',          // sm, md, lg
  fullWidth = false,
  disabled = false,
  loading = false,
  onClick,
  children 
}) => {
  const baseClass = 'bm-button';
  const variantClass = `bm-button--${variant}`;
  const sizeClass = `bm-button--${size}`;
  
  return (
    <button
      className={`${baseClass} ${variantClass} ${sizeClass} ${fullWidth ? 'bm-button--full' : ''}`}
      disabled={disabled || loading}
      onClick={onClick}
    >
      {loading ? 'Loading...' : children}
    </button>
  );
};
```

**CartItemCard Component** (`CartItemCard.jsx`)
```jsx
const CartItemCard = ({
  // Basic info
  code,
  title,
  type,
  area,
  price,
  mode = 'rent',        // 'rent' | 'buy'
  months = 1,
  status = 'for_rent',
  
  // Location hierarchy
  block,
  building,
  floor,
  
  // Apartment details
  bedrooms,
  bathrooms,
  balconies,
  parkingSlots,
  amenities = [],
  
  // Financial details
  maintenanceFee = 0,
  deposit = 0,
  
  // Actions
  onMonthsChange,
  onRemove,
  onSelectToggle,
  selected = false,
  selectable = false
}) => {
  const totalPrice = mode === 'rent' ? price * months : price;
  const totalDeposit = mode === 'rent' ? deposit : 0;
  const totalMaintenance = mode === 'rent' 
    ? maintenanceFee * months 
    : maintenanceFee * 12;
  const grandTotal = totalPrice + totalDeposit + totalMaintenance;

  return (
    <Card
      title={title || 'Apartment'}
      className="bm-cart-card"
      footer={
        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
          <div style={{ fontWeight: 600 }}>
            {mode === 'rent'
              ? `${formatPrice(price)} Ä‘/thÃ¡ng x ${months} = ${formatPrice(price * months)} Ä‘`
              : `${formatPrice(price)} Ä‘`}
          </div>
          {mode === 'rent' && (
            <div style={{ display: 'flex', gap: 8 }}>
              <Button variant="secondary" size="sm" onClick={() => onMonthsChange(months - 1)}>
                -
              </Button>
              <div>{months}m</div>
              <Button variant="secondary" size="sm" onClick={() => onMonthsChange(months + 1)}>
                +
              </Button>
            </div>
          )}
        </div>
      }
    >
      {/* Card content with apartment details */}
    </Card>
  );
};
```

**CartSummary Component** (`CartSummary.jsx`)
```jsx
const CartSummary = ({ items = [], onCheckout, onSelectAll, onClear }) => {
  const { rentTotal, buyTotal, selectedCount } = useMemo(() => {
    let rent = 0;
    let buy = 0;
    let count = 0;
    
    items.forEach((item) => {
      if (item.selected) {
        count += 1;
        if (item.mode === 'rent') rent += (item.price || 0) * (item.months || 1);
        if (item.mode === 'buy') buy += (item.price || 0);
      }
    });
    
    return { rentTotal: rent, buyTotal: buy, selectedCount: count };
  }, [items]);

  return (
    <Card title="Cart Summary">
      <div style={{ display: 'grid', gap: 8 }}>
        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
          <span>Items selected</span>
          <strong>{selectedCount}</strong>
        </div>
        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
          <span>Rent total</span>
          <strong>{formatPrice(rentTotal)} Ä‘</strong>
        </div>
        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
          <span>Buy total</span>
          <strong>{formatPrice(buyTotal)} Ä‘</strong>
        </div>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: 8 }}>
          <span>Grand total</span>
          <strong>{formatPrice(rentTotal + buyTotal)} Ä‘</strong>
        </div>
      </div>
      <Button
        variant="primary"
        fullWidth
        disabled={selectedCount === 0}
        onClick={onCheckout}
      >
        Checkout {selectedCount > 0 ? `(${selectedCount})` : ''}
      </Button>
    </Card>
  );
};
```

#### 1.3 Custom Hook - useCart

```javascript
// hooks/useCart.js
import { useMemo, useState, useCallback } from 'react';

const useCart = (initial = [], options = {}) => {
  const { apiUrl = '/api/cart', authToken = null } = options;
  const [items, setItems] = useState(initial);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Sync with backend
  const syncWithBackend = useCallback(async () => {
    if (!authToken) return;

    setLoading(true);
    setError(null);

    try {
      const response = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) throw new Error('Failed to fetch cart');

      const data = await response.json();
      setItems(data.items || data || []);
    } catch (err) {
      setError(err.message);
      console.error('Cart sync error:', err);
    } finally {
      setLoading(false);
    }
  }, [apiUrl, authToken]);

  // Validate apartment availability
  const validateItem = useCallback(async (apartmentId, mode) => {
    if (!authToken) return { valid: true };

    try {
      const response = await fetch(`/api/apartments/${apartmentId}`, {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) throw new Error('Failed to validate apartment');

      const apartment = await response.json();

      // Check availability based on mode
      if (mode === 'rent' && !apartment.isListedForRent) {
        return { valid: false, reason: 'Apartment is not available for rent' };
      }

      if (mode === 'buy' && !apartment.isListedForSale) {
        return { valid: false, reason: 'Apartment is not available for sale' };
      }

      if (!['vacant', 'for_rent', 'for_sale'].includes(apartment.status)) {
        return { valid: false, reason: `Apartment is ${apartment.status}` };
      }

      return { valid: true, apartment };
    } catch (err) {
      return { valid: false, reason: err.message };
    }
  }, [authToken]);

  // Calculate detailed totals
  const calculateTotal = useCallback((item) => {
    const basePrice = item.price || 0;
    const months = item.months || 1;

    let subtotal = 0;
    let deposit = 0;
    let maintenance = 0;

    if (item.mode === 'rent') {
      subtotal = basePrice * months;
      deposit = item.deposit || (basePrice * 2); // 2 months deposit
      maintenance = (item.maintenanceFee || 0) * months;
    } else {
      subtotal = basePrice;
      deposit = 0;
      maintenance = (item.maintenanceFee || 0) * 12; // Annual maintenance
    }

    const total = subtotal + deposit + maintenance;

    return { subtotal, deposit, maintenance, total };
  }, []);

  // Add to cart
  const addItem = useCallback((item) => {
    setItems(prevItems => {
      const existingIndex = prevItems.findIndex(
        i => i.apartmentId === item.apartmentId && i.mode === item.mode
      );

      if (existingIndex >= 0) {
        // Update existing item
        const newItems = [...prevItems];
        newItems[existingIndex] = { ...newItems[existingIndex], ...item };
        return newItems;
      }

      // Add new item
      return [...prevItems, { ...item, id: Date.now(), selected: true }];
    });
  }, []);

  // Remove from cart
  const removeItem = useCallback((id) => {
    setItems(prevItems => prevItems.filter(item => item.id !== id));
  }, []);

  // Update item
  const updateItem = useCallback((id, updates) => {
    setItems(prevItems =>
      prevItems.map(item => (item.id === id ? { ...item, ...updates } : item))
    );
  }, []);

  // Toggle selection
  const toggleSelection = useCallback((id) => {
    setItems(prevItems =>
      prevItems.map(item =>
        item.id === id ? { ...item, selected: !item.selected } : item
      )
    );
  }, []);

  // Select all
  const selectAll = useCallback((selected = true) => {
    setItems(prevItems => prevItems.map(item => ({ ...item, selected })));
  }, []);

  // Clear cart
  const clearCart = useCallback(() => {
    setItems([]);
  }, []);

  // Memoized totals
  const totals = useMemo(() => {
    let rentTotal = 0;
    let buyTotal = 0;
    let depositTotal = 0;
    let maintenanceTotal = 0;
    let selectedCount = 0;

    items.forEach((item) => {
      if (item.selected) {
        selectedCount += 1;
        const itemTotal = calculateTotal(item);
        
        if (item.mode === 'rent') {
          rentTotal += itemTotal.subtotal;
          depositTotal += itemTotal.deposit;
          maintenanceTotal += itemTotal.maintenance;
        } else {
          buyTotal += itemTotal.subtotal;
          maintenanceTotal += itemTotal.maintenance;
        }
      }
    });

    const grandTotal = rentTotal + buyTotal + depositTotal + maintenanceTotal;

    return {
      rentTotal,
      buyTotal,
      depositTotal,
      maintenanceTotal,
      grandTotal,
      selectedCount,
      totalItems: items.length
    };
  }, [items, calculateTotal]);

  return {
    items,
    totals,
    loading,
    error,
    addItem,
    removeItem,
    updateItem,
    toggleSelection,
    selectAll,
    clearCart,
    syncWithBackend,
    validateItem,
    calculateTotal
  };
};

export default useCart;
```

**TÃ­nh nÄƒng chÃ­nh cá»§a useCart**:
- âœ… State management cho cart items
- âœ… CRUD operations (add, remove, update)
- âœ… Selection management (toggle, select all)
- âœ… Financial calculations (totals, deposits, maintenance)
- âœ… Backend sync vá»›i REST API
- âœ… Apartment availability validation
- âœ… JWT authentication support
- âœ… Error handling vÃ  loading states

### 2. GraphQL Integration (lab05_ManageBuilding)

#### 2.1 Apollo Server Setup

```javascript
// backend/src/server.js
const { ApolloServer } = require('apollo-server-express');
const jwt = require('jsonwebtoken');

// GraphQL imports
const cartTypeDefs = require('./graphql/cart.schema');
const cartResolvers = require('./graphql/cart.resolvers');

// Apollo Server setup
const apolloServer = new ApolloServer({
    typeDefs: cartTypeDefs,
    resolvers: cartResolvers,
    context: async ({ req }) => {
        // Extract user from JWT token
        const token = req.headers.authorization?.replace('Bearer ', '') || 
                      req.cookies?.token;

        if (token) {
            try {
                const decoded = jwt.verify(token, process.env.JWT_SECRET);
                const { User, Role } = require('./models');
                const user = await User.findByPk(decoded.id, {
                    include: [{ model: Role, as: 'role' }]
                });
                return { user };
            } catch (error) {
                console.log('GraphQL auth error:', error.message);
                return { user: null };
            }
        }

        return { user: null };
    },
    formatError: (error) => {
        console.error('GraphQL Error:', error);
        return {
            message: error.message,
            locations: error.locations,
            path: error.path
        };
    }
});

// Start Apollo Server
await apolloServer.start();
apolloServer.applyMiddleware({
    app,
    path: '/graphql',
    cors: {
        origin: process.env.CLIENT_URL || 'http://localhost:3000',
        credentials: true
    }
});
```

**Context authentication**:
- Tá»± Ä‘á»™ng extract JWT token tá»« `Authorization` header hoáº·c cookies
- Validate token vÃ  load user vá»›i role information
- Inject `user` object vÃ o GraphQL context cho táº¥t cáº£ resolvers
- Graceful error handling náº¿u token invalid

#### 2.2 GraphQL Schema

```javascript
// backend/src/graphql/cart.schema.js
const { gql } = require('apollo-server-express');

const cartTypeDefs = gql`
  # Cart item type with full details
  type CartItem {
    id: ID!
    apartmentId: Int!
    apartment: Apartment!
    code: String!
    title: String!
    type: String!
    area: Float!
    price: Float!
    mode: CartMode!
    months: Int
    status: String!
    selected: Boolean!
    note: String
    
    # Location hierarchy
    block: String
    building: String
    floor: String
    
    # Apartment details
    bedrooms: Int
    bathrooms: Int
    balconies: Int
    parkingSlots: Int
    amenities: [String!]
    
    # Financial
    maintenanceFee: Float!
    deposit: Float!
    
    addedAt: String!
  }

  # Cart mode enum
  enum CartMode {
    RENT
    BUY
  }

  # Summary calculations
  type CartSummary {
    rentTotal: Float!
    buyTotal: Float!
    depositTotal: Float!
    maintenanceTotal: Float!
    grandTotal: Float!
    selectedCount: Int!
    totalItems: Int!
  }

  # Cart response with items and summary
  type CartResponse {
    items: [CartItem!]!
    summary: CartSummary!
  }

  # Apartment type
  type Apartment {
    id: ID!
    apartmentNumber: String!
    type: String!
    area: Float!
    bedrooms: Int!
    bathrooms: Int!
    balconies: Int
    parkingSlots: Int
    monthlyRent: Float
    salePrice: Float
    isListedForRent: Boolean!
    isListedForSale: Boolean!
    maintenanceFee: Float!
    status: String!
    description: String
    amenities: [String!]
  }

  # Input types
  input AddToCartInput {
    apartmentId: Int!
    mode: CartMode!
    months: Int
    note: String
  }

  input UpdateCartItemInput {
    months: Int
    selected: Boolean
    note: String
  }

  input CheckoutInput {
    paymentMethod: String!
    note: String
  }

  # Payment result
  type Payment {
    id: ID!
    transactionId: String!
    apartmentId: Int!
    amount: Float!
    paymentMethod: String!
    status: String!
    createdAt: String!
  }

  type CheckoutResult {
    success: Boolean!
    payments: [Payment!]!
    completedApartments: [Int!]!
    message: String!
  }

  # Queries
  type Query {
    # Get user's cart with all items and summary
    myCart: CartResponse!
    
    # Get cart summary only
    cartSummary: CartSummary!
  }

  # Mutations
  type Mutation {
    # Add item to cart (manual add - optional)
    addToCart(input: AddToCartInput!): CartItem!
    
    # Update cart item
    updateCartItem(id: ID!, input: UpdateCartItemInput!): CartItem!
    
    # Remove item from cart
    removeFromCart(id: ID!): Boolean!
    
    # Toggle cart item selection
    toggleCartItemSelection(id: ID!, selected: Boolean!): CartItem!
    
    # Select/deselect all cart items
    selectAllCartItems(selected: Boolean): [CartItem!]!
    
    # Clear all cart items
    clearCart: Boolean!
    
    # Checkout cart - Process payment for selected items
    checkoutCart(input: CheckoutInput!): CheckoutResult!
  }
`;

module.exports = cartTypeDefs;
```

**Schema design highlights**:
- **Strong typing**: Sá»­ dá»¥ng custom types (CartItem, Apartment, Payment)
- **Enums**: CartMode enum cho type safety (RENT/BUY)
- **Input types**: Validated inputs cho mutations
- **Nested objects**: CartItem includes Apartment details
- **Calculated fields**: CartSummary vá»›i totals, counts
- **Flexible queries**: Separate queries cho full cart vÃ  summary only

#### 2.3 GraphQL Resolvers

```javascript
// backend/src/graphql/cart.resolvers.js
const cartService = require('../services/cart.service');

const cartResolvers = {
    Query: {
        /**
         * Get user's cart with all items and summary
         */
        myCart: async (_, __, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            return await cartService.getCartSummary(user.id);
        },

        /**
         * Get cart summary only
         */
        cartSummary: async (_, __, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            const data = await cartService.getCartSummary(user.id);
            return data.summary;
        }
    },

    Mutation: {
        /**
         * Add item to cart
         */
        addToCart: async (_, { input }, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            const { apartmentId, mode, months, note } = input;

            return await cartService.addToCart(user.id, {
                apartmentId,
                mode: mode.toLowerCase(),
                months,
                note
            });
        },

        /**
         * Update cart item
         */
        updateCartItem: async (_, { id, input }, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            return await cartService.updateCartItem(user.id, id, input);
        },

        /**
         * Remove item from cart
         */
        removeFromCart: async (_, { id }, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            await cartService.removeFromCart(user.id, id);
            return true;
        },

        /**
         * Toggle cart item selection
         */
        toggleCartItemSelection: async (_, { id, selected }, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            return await cartService.toggleSelection(user.id, id, selected);
        },

        /**
         * Select/deselect all cart items
         */
        selectAllCartItems: async (_, { selected = true }, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            return await cartService.selectAll(user.id, selected);
        },

        /**
         * Clear all cart items
         */
        clearCart: async (_, __, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            await cartService.clearCart(user.id);
            return true;
        },

        /**
         * Checkout cart - Process payment for selected items
         */
        checkoutCart: async (_, { input }, { user }) => {
            if (!user) {
                throw new Error('Authentication required');
            }

            const { paymentMethod, note } = input;

            return await cartService.checkoutCart(user.id, {
                paymentMethod,
                note
            });
        }
    },

    CartItem: {
        /**
         * Resolve apartment details for cart item
         */
        apartment: async (cartItem) => {
            // Return apartment data from already loaded association
            return cartItem.apartment;
        }
    }
};

module.exports = cartResolvers;
```

**Resolver patterns**:
- **Authentication check**: Má»i resolver Ä‘á»u check `user` tá»« context
- **Service layer**: Delegate business logic to `cartService`
- **Error handling**: Throw descriptive errors cho client
- **Field resolvers**: `CartItem.apartment` resolver cho nested data
- **Async/await**: Consistent async pattern throughout

#### 2.4 Cart Service (Business Logic)

```javascript
// backend/src/services/cart.service.js (key methods)
const { Cart, Apartment, Floor, Building, Block } = require('../models');

class CartService {
    /**
     * Get all cart items for a user with summary
     */
    async getCartSummary(userId) {
        const cartItems = await Cart.findAll({
            where: { userId },
            include: [
                {
                    model: Apartment,
                    as: 'apartment',
                    include: [
                        {
                            model: Floor,
                            as: 'floor',
                            include: [
                                {
                                    model: Building,
                                    as: 'building',
                                    include: [
                                        { model: Block, as: 'block' }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ],
            order: [['addedAt', 'DESC']]
        });

        const items = cartItems.map(item => this.formatCartItem(item));

        // Calculate summary
        let rentTotal = 0;
        let buyTotal = 0;
        let depositTotal = 0;
        let maintenanceTotal = 0;
        let selectedCount = 0;

        items.forEach(item => {
            if (item.selected) {
                selectedCount++;
                const months = item.months || 1;

                if (item.mode === 'rent') {
                    rentTotal += item.price * months;
                    depositTotal += item.deposit;
                    maintenanceTotal += item.maintenanceFee * months;
                } else {
                    buyTotal += item.price;
                    maintenanceTotal += item.maintenanceFee * 12;
                }
            }
        });

        const grandTotal = rentTotal + buyTotal + depositTotal + maintenanceTotal;

        return {
            items,
            summary: {
                rentTotal,
                buyTotal,
                depositTotal,
                maintenanceTotal,
                grandTotal,
                selectedCount,
                totalItems: items.length
            }
        };
    }

    /**
     * Add item to cart
     */
    async addToCart(userId, data) {
        const { apartmentId, mode, months, note } = data;

        // Check apartment availability
        const apartment = await Apartment.findByPk(apartmentId, {
            include: [
                {
                    model: Floor,
                    as: 'floor',
                    include: [
                        {
                            model: Building,
                            as: 'building',
                            include: [{ model: Block, as: 'block' }]
                        }
                    ]
                }
            ]
        });

        if (!apartment) {
            throw new Error('Apartment not found');
        }

        // Validate availability based on mode
        if (mode === 'rent' && !apartment.isListedForRent) {
            throw new Error('Apartment is not available for rent');
        }

        if (mode === 'buy' && !apartment.isListedForSale) {
            throw new Error('Apartment is not available for sale');
        }

        // Check status
        const validStatuses = ['vacant', 'for_rent', 'for_sale'];
        if (!validStatuses.includes(apartment.status)) {
            throw new Error(`Apartment is ${apartment.status} and not available`);
        }

        // Check if item already exists
        const existingItem = await Cart.findOne({
            where: { userId, apartmentId, mode }
        });

        if (existingItem) {
            // Update existing item
            await existingItem.update({
                months: mode === 'rent' ? months : null,
                note,
                priceSnapshot: mode === 'rent' ? apartment.monthlyRent : apartment.salePrice,
                depositSnapshot: mode === 'rent' ? apartment.monthlyRent * 2 : 0,
                maintenanceFeeSnapshot: apartment.maintenanceFee
            });

            return this.formatCartItem(await Cart.findByPk(existingItem.id, {
                include: [/* associations */]
            }));
        }

        // Create new cart item
        const cartItem = await Cart.create({
            userId,
            apartmentId,
            mode,
            months: mode === 'rent' ? months || 12 : null,
            note,
            priceSnapshot: mode === 'rent' ? apartment.monthlyRent : apartment.salePrice,
            depositSnapshot: mode === 'rent' ? apartment.monthlyRent * 2 : 0,
            maintenanceFeeSnapshot: apartment.maintenanceFee,
            selected: true
        });

        return this.formatCartItem(await Cart.findByPk(cartItem.id, {
            include: [/* associations */]
        }));
    }

    /**
     * Checkout cart - Process payment for selected items
     */
    async checkoutCart(userId, data) {
        const { sequelize } = require('../config/database');
        const { Payment, Role, Billing } = require('../models');
        const { paymentMethod, note } = data;

        // Start transaction
        const transaction = await sequelize.transaction();

        try {
            // 1. Get selected cart items
            const cartItems = await Cart.findAll({
                where: { userId, selected: true },
                include: [
                    {
                        model: Apartment,
                        as: 'apartment',
                        include: [
                            {
                                model: Floor,
                                as: 'floor',
                                include: [
                                    { model: Building, as: 'building' }
                                ]
                            }
                        ]
                    }
                ],
                transaction
            });

            if (cartItems.length === 0) {
                throw new Error('No items selected for checkout');
            }

            // 2. Validate all apartments are still available
            for (const item of cartItems) {
                const apartment = item.apartment;
                const availableStatuses = ['for_rent', 'for_sale'];
                
                if (!availableStatuses.includes(apartment.status)) {
                    throw new Error(
                        `Apartment ${apartment.apartmentNumber} is no longer available`
                    );
                }

                if (item.mode === 'rent' && apartment.status !== 'for_rent') {
                    throw new Error(
                        `Apartment ${apartment.apartmentNumber} is not available for rent`
                    );
                }
                
                if (item.mode === 'buy' && apartment.status !== 'for_sale') {
                    throw new Error(
                        `Apartment ${apartment.apartmentNumber} is not available for sale`
                    );
                }
            }

            const payments = [];
            const completedApartments = [];

            // 3. Process each cart item
            for (const cartItem of cartItems) {
                const apartment = cartItem.apartment;
                const amount = cartItem.mode === 'rent'
                    ? (cartItem.priceSnapshot || apartment.monthlyRent) * (cartItem.months || 1)
                    : (cartItem.priceSnapshot || apartment.salePrice);

                // Create billing record
                const billing = await Billing.create({
                    apartmentId: apartment.id,
                    billType: cartItem.mode === 'rent' ? 'rent' : 'other',
                    description: `${cartItem.mode === 'rent' ? 'Rent' : 'Purchase'} payment`,
                    amount: amount,
                    billDate: new Date(),
                    dueDate: new Date(),
                    status: 'paid',
                    lateFee: 0,
                }, { transaction });

                // Create payment record
                const payment = await Payment.create({
                    userId,
                    apartmentId: apartment.id,
                    billingId: billing.id,
                    amount,
                    paymentMethod,
                    transactionId: `TXN-${Date.now()}-${apartment.id}`,
                    status: 'completed',
                    note: note || `${cartItem.mode} payment for ${apartment.apartmentNumber}`
                }, { transaction });

                payments.push(payment);
                completedApartments.push(apartment.id);

                // Update apartment status
                if (cartItem.mode === 'rent') {
                    await apartment.update({
                        status: 'occupied',
                        isListedForRent: false
                    }, { transaction });
                } else {
                    await apartment.update({
                        status: 'occupied',
                        isListedForSale: false
                    }, { transaction });
                }
            }

            // 4. Upgrade user to resident role
            const user = await User.findByPk(userId, {
                include: [{ model: Role, as: 'role' }],
                transaction
            });

            const residentRole = await Role.findOne({
                where: { name: 'resident' },
                transaction
            });

            if (residentRole && user.roleId !== residentRole.id) {
                await user.update({ roleId: residentRole.id }, { transaction });
            }

            // 5. Clear cart
            await Cart.destroy({
                where: { userId, selected: true },
                transaction
            });

            // Commit transaction
            await transaction.commit();

            return {
                success: true,
                payments: payments.map(p => this.formatPayment(p)),
                completedApartments,
                message: `Successfully processed ${payments.length} payment(s)`
            };

        } catch (error) {
            // Rollback transaction on error
            await transaction.rollback();
            throw error;
        }
    }

    /**
     * Format cart item for GraphQL response
     */
    formatCartItem(cartItem) {
        const apartment = cartItem.apartment;
        const floor = apartment?.floor;
        const building = floor?.building;
        const block = building?.block;

        return {
            id: cartItem.id,
            apartmentId: cartItem.apartmentId,
            code: apartment?.code || `${building?.code}-${apartment?.apartmentNumber}`,
            title: `Apartment ${apartment?.apartmentNumber}`,
            type: apartment?.type,
            area: apartment?.area,
            price: cartItem.priceSnapshot,
            mode: cartItem.mode,
            months: cartItem.months,
            status: apartment?.status,
            selected: cartItem.selected,
            note: cartItem.note,
            
            // Location hierarchy
            block: block?.name,
            building: building?.name,
            floor: `Floor ${floor?.floorNumber}`,
            
            // Apartment details
            bedrooms: apartment?.bedrooms,
            bathrooms: apartment?.bathrooms,
            balconies: apartment?.balconies,
            parkingSlots: apartment?.parkingSlots,
            
            // Financial
            maintenanceFee: cartItem.maintenanceFeeSnapshot,
            deposit: cartItem.depositSnapshot,
            
            // Metadata
            addedAt: cartItem.addedAt,
            
            // Nested apartment object
            apartment: {
                id: apartment?.id,
                apartmentNumber: apartment?.apartmentNumber,
                type: apartment?.type,
                area: apartment?.area,
                bedrooms: apartment?.bedrooms,
                bathrooms: apartment?.bathrooms,
                balconies: apartment?.balconies,
                parkingSlots: apartment?.parkingSlots,
                monthlyRent: apartment?.monthlyRent,
                salePrice: apartment?.salePrice,
                isListedForRent: apartment?.isListedForRent,
                isListedForSale: apartment?.isListedForSale,
                maintenanceFee: apartment?.maintenanceFee,
                status: apartment?.status,
                description: apartment?.description,
                amenities: apartment?.amenities || [],
            }
        };
    }
}

module.exports = new CartService();
```

**Business logic highlights**:
- **Hierarchical data loading**: Include Blockâ†’Buildingâ†’Floorâ†’Apartment associations
- **Summary calculations**: Separate totals cho rent, buy, deposits, maintenance
- **Availability validation**: Check apartment status vÃ  listing flags
- **Transaction management**: Sequelize transactions cho checkout integrity
- **Price snapshots**: Store prices at time of adding to cart (prevent price changes)
- **Role upgrade**: Auto-upgrade user to resident after successful payment
- **Atomic operations**: All-or-nothing checkout with rollback on error

## ðŸ”„ CÆ¡ cháº¿ hoáº¡t Ä‘á»™ng

### Workflow 1: Add to Cart Flow

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant GraphQL API
    participant CartService
    participant Database

    User->>Frontend: Click "Add to Cart"
    Frontend->>GraphQL API: mutation addToCart(apartmentId, mode, months)
    GraphQL API->>GraphQL API: Verify JWT token from Authorization header
    GraphQL API->>CartService: addToCart(userId, data)
    CartService->>Database: Check apartment availability
    Database-->>CartService: Apartment data
    CartService->>CartService: Validate status (vacant/for_rent/for_sale)
    CartService->>CartService: Validate listing flags (isListedForRent/Sale)
    CartService->>Database: Check existing cart item
    
    alt Item exists
        CartService->>Database: Update existing cart item
    else New item
        CartService->>Database: Create new cart item
    end
    
    Database-->>CartService: Cart item with associations
    CartService->>CartService: formatCartItem() - Build response
    CartService-->>GraphQL API: Formatted CartItem
    GraphQL API-->>Frontend: CartItem with apartment details
    Frontend->>Frontend: Update local state (useCart hook)
    Frontend-->>User: Show success message + updated cart
```

### Workflow 2: Checkout Flow

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant GraphQL API
    participant CartService
    participant Database

    User->>Frontend: Click "Checkout"
    Frontend->>Frontend: Validate selected items > 0
    Frontend->>GraphQL API: mutation checkoutCart(paymentMethod, note)
    GraphQL API->>GraphQL API: Verify JWT token
    GraphQL API->>CartService: checkoutCart(userId, data)
    
    CartService->>Database: START TRANSACTION
    CartService->>Database: Get selected cart items with apartments
    
    alt No items selected
        CartService-->>GraphQL API: Error: No items selected
        GraphQL API-->>Frontend: Error message
        Frontend-->>User: Show error toast
    end
    
    CartService->>CartService: Validate all apartments availability
    
    loop For each cart item
        CartService->>Database: Create Billing record
        CartService->>Database: Create Payment record
        CartService->>Database: Update apartment status (â†’ occupied)
        CartService->>Database: Update listing flags (â†’ false)
    end
    
    CartService->>Database: Get user current role
    CartService->>Database: Find resident role
    
    alt User is not resident
        CartService->>Database: Update user roleId to resident
    end
    
    CartService->>Database: Delete selected cart items
    CartService->>Database: COMMIT TRANSACTION
    
    CartService-->>GraphQL API: CheckoutResult (success, payments, apartments)
    GraphQL API-->>Frontend: Checkout success with details
    Frontend->>Frontend: Clear cart state
    Frontend->>Frontend: Redirect to success page
    Frontend-->>User: Show success message + payment details
```

### Workflow 3: GraphQL Query/Mutation Flow

```mermaid
graph TD
    A[Client Request] --> B{Request Type}
    
    B -->|Query: myCart| C[Extract JWT from Header]
    B -->|Mutation: checkoutCart| C
    
    C --> D{Token Valid?}
    
    D -->|No| E[Return Authentication Error]
    D -->|Yes| F[Decode JWT â†’ userId]
    
    F --> G[Load User + Role from DB]
    G --> H[Build GraphQL Context]
    H --> I{Context user exists?}
    
    I -->|No| J[Resolver throws Auth Error]
    I -->|Yes| K[Execute Resolver]
    
    K --> L{Operation Type}
    
    L -->|Query| M[cartService.getCartSummary]
    L -->|Mutation| N[cartService.checkoutCart]
    
    M --> O[Load cart items with associations]
    N --> P[Start DB transaction]
    
    O --> Q[Calculate summary totals]
    P --> R[Process payments + update DB]
    
    Q --> S[Format response]
    R --> T{Transaction success?}
    
    T -->|Yes| U[Commit + return result]
    T -->|No| V[Rollback + throw error]
    
    S --> W[Return CartResponse]
    U --> W
    V --> X[Return error to client]
    W --> X
    
    X --> Y[Frontend receives response]
    Y --> Z[Update UI state]
```

## ðŸ“Š VÃ­ dá»¥ cá»¥ thá»ƒ

### 1. Using Component Library in lab05 Frontend

```jsx
// lab05_ManageBuilding/frontend/src/pages/Cart.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useMutation, useQuery } from '@apollo/client';
import { 
  CartItemCard, 
  CartSummary, 
  useCart 
} from '../../../lab07_CartComponent/src';
import '../../../lab07_CartComponent/src/styles.css';
import { CHECKOUT_CART } from '../graphql/mutations';
import { MY_CART } from '../graphql/queries';

const Cart = () => {
  const navigate = useNavigate();
  const authToken = localStorage.getItem('token');

  // GraphQL query to get cart data
  const { data, loading, error, refetch } = useQuery(MY_CART);

  // GraphQL mutation for checkout
  const [checkoutMutation, { loading: checkoutLoading }] = useMutation(CHECKOUT_CART);

  // useCart hook for local state management
  const {
    items,
    totals,
    updateItem,
    removeItem,
    toggleSelection,
    selectAll,
    clearCart
  } = useCart(data?.myCart?.items || [], {
    apiUrl: '/api/cart',
    authToken
  });

  useEffect(() => {
    if (data?.myCart?.items) {
      // Sync with GraphQL data
      data.myCart.items.forEach(item => {
        updateItem(item.id, item);
      });
    }
  }, [data]);

  const handleCheckout = async () => {
    if (totals.selectedCount === 0) {
      alert('Please select items to checkout');
      return;
    }

    try {
      const result = await checkoutMutation({
        variables: {
          input: {
            paymentMethod: 'credit_card',
            note: 'Online payment'
          }
        }
      });

      if (result.data.checkoutCart.success) {
        clearCart();
        alert(`Checkout successful! Processed ${result.data.checkoutCart.payments.length} payments.`);
        navigate('/my-apartments');
        refetch();
      }
    } catch (err) {
      console.error('Checkout error:', err);
      alert('Checkout failed: ' + err.message);
    }
  };

  if (loading) return <div>Loading cart...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div className="cart-page">
      <h1>My Cart</h1>
      
      <div className="cart-layout">
        <div className="cart-items">
          {items.length === 0 ? (
            <p>Your cart is empty</p>
          ) : (
            items.map(item => (
              <CartItemCard
                key={item.id}
                code={item.code}
                title={item.title}
                type={item.type}
                area={item.area}
                price={item.price}
                mode={item.mode}
                months={item.months}
                status={item.status}
                block={item.block}
                building={item.building}
                floor={item.floor}
                bedrooms={item.bedrooms}
                bathrooms={item.bathrooms}
                balconies={item.balconies}
                parkingSlots={item.parkingSlots}
                amenities={item.amenities}
                maintenanceFee={item.maintenanceFee}
                deposit={item.deposit}
                selected={item.selected}
                selectable={true}
                onSelectToggle={() => toggleSelection(item.id)}
                onMonthsChange={(newMonths) => updateItem(item.id, { months: newMonths })}
                onRemove={() => removeItem(item.id)}
              />
            ))
          )}
        </div>

        <div className="cart-sidebar">
          <CartSummary
            items={items}
            onCheckout={handleCheckout}
            onSelectAll={() => selectAll(true)}
            onClear={() => {
              if (confirm('Clear all items?')) clearCart();
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default Cart;
```

### 2. GraphQL Queries/Mutations

```javascript
// lab05_ManageBuilding/frontend/src/graphql/queries.js
import { gql } from '@apollo/client';

export const MY_CART = gql`
  query MyCart {
    myCart {
      items {
        id
        apartmentId
        code
        title
        type
        area
        price
        mode
        months
        status
        selected
        note
        block
        building
        floor
        bedrooms
        bathrooms
        balconies
        parkingSlots
        amenities
        maintenanceFee
        deposit
        addedAt
        apartment {
          id
          apartmentNumber
          type
          area
          status
          isListedForRent
          isListedForSale
          monthlyRent
          salePrice
        }
      }
      summary {
        rentTotal
        buyTotal
        depositTotal
        maintenanceTotal
        grandTotal
        selectedCount
        totalItems
      }
    }
  }
`;

export const CART_SUMMARY = gql`
  query CartSummary {
    cartSummary {
      rentTotal
      buyTotal
      depositTotal
      maintenanceTotal
      grandTotal
      selectedCount
      totalItems
    }
  }
`;
```

```javascript
// lab05_ManageBuilding/frontend/src/graphql/mutations.js
import { gql } from '@apollo/client';

export const ADD_TO_CART = gql`
  mutation AddToCart($input: AddToCartInput!) {
    addToCart(input: $input) {
      id
      apartmentId
      code
      title
      mode
      months
      price
      selected
    }
  }
`;

export const TOGGLE_CART_SELECTION = gql`
  mutation ToggleCartItemSelection($id: ID!, $selected: Boolean!) {
    toggleCartItemSelection(id: $id, selected: $selected) {
      id
      selected
    }
  }
`;

export const CHECKOUT_CART = gql`
  mutation CheckoutCart($input: CheckoutInput!) {
    checkoutCart(input: $input) {
      success
      message
      payments {
        id
        transactionId
        apartmentId
        amount
        paymentMethod
        status
        createdAt
      }
      completedApartments
    }
  }
`;
```

### 3. Testing GraphQL vá»›i curl

```bash
# Get cart with items and summary
curl -X POST http://localhost:5000/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "query": "query { myCart { items { id code title price mode months selected } summary { grandTotal selectedCount } } }"
  }'

# Response:
{
  "data": {
    "myCart": {
      "items": [
        {
          "id": "1",
          "code": "S.01-0302",
          "title": "Apartment 302",
          "price": 7500000,
          "mode": "rent",
          "months": 12,
          "selected": true
        }
      ],
      "summary": {
        "grandTotal": 105000000,
        "selectedCount": 1
      }
    }
  }
}

# Add item to cart
curl -X POST http://localhost:5000/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "query": "mutation($input: AddToCartInput!) { addToCart(input: $input) { id code title mode months } }",
    "variables": {
      "input": {
        "apartmentId": 15,
        "mode": "RENT",
        "months": 12,
        "note": "Looking for 1 year lease"
      }
    }
  }'

# Checkout cart
curl -X POST http://localhost:5000/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "query": "mutation($input: CheckoutInput!) { checkoutCart(input: $input) { success message payments { transactionId amount } } }",
    "variables": {
      "input": {
        "paymentMethod": "credit_card",
        "note": "Online payment via GraphQL"
      }
    }
  }'

# Response:
{
  "data": {
    "checkoutCart": {
      "success": true,
      "message": "Successfully processed 1 payment(s)",
      "payments": [
        {
          "transactionId": "TXN-1702123456789-15",
          "amount": 105000000
        }
      ]
    }
  }
}
```

### 4. GraphQL Playground Usage

Access playground táº¡i: `http://localhost:5000/graphql`

**Query example**:
```graphql
query GetMyCart {
  myCart {
    items {
      id
      code
      title
      type
      area
      price
      mode
      months
      selected
      block
      building
      floor
      bedrooms
      bathrooms
      maintenanceFee
      deposit
      apartment {
        apartmentNumber
        status
        isListedForRent
        isListedForSale
      }
    }
    summary {
      rentTotal
      buyTotal
      depositTotal
      maintenanceTotal
      grandTotal
      selectedCount
      totalItems
    }
  }
}
```

**Mutation example**:
```graphql
mutation CheckoutMyCart {
  checkoutCart(input: {
    paymentMethod: "credit_card"
    note: "Payment from GraphQL Playground"
  }) {
    success
    message
    payments {
      id
      transactionId
      apartmentId
      amount
      paymentMethod
      status
      createdAt
    }
    completedApartments
  }
}
```

**Headers** (trong playground):
```json
{
  "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

## ðŸŽ¯ Káº¿t quáº£ Ä‘áº¡t Ä‘Æ°á»£c

| Chá»©c nÄƒng | MÃ´ táº£ | Status |
|-----------|-------|--------|
| **Component Library** | Reusable React components cho cart UI | âœ… HoÃ n thÃ nh |
| **useCart Hook** | Custom hook quáº£n lÃ½ cart state | âœ… HoÃ n thÃ nh |
| **GraphQL Schema** | Strongly-typed API vá»›i CartItem, CartSummary types | âœ… HoÃ n thÃ nh |
| **GraphQL Resolvers** | Query (myCart, cartSummary) + 7 mutations | âœ… HoÃ n thÃ nh |
| **Authentication** | JWT-based auth trong GraphQL context | âœ… HoÃ n thÃ nh |
| **Dual Mode Support** | Rent vÃ  Buy modes vá»›i financial calculations | âœ… HoÃ n thÃ nh |
| **Transaction Safety** | Sequelize transactions cho checkout atomicity | âœ… HoÃ n thÃ nh |
| **Validation** | Apartment availability checking | âœ… HoÃ n thÃ nh |
| **Price Snapshots** | Store prices at add-to-cart time | âœ… HoÃ n thÃ nh |
| **Role Upgrade** | Auto-upgrade to resident after payment | âœ… HoÃ n thÃ nh |
| **Error Handling** | Graceful errors vá»›i rollback | âœ… HoÃ n thÃ nh |
| **GraphQL Playground** | Interactive API testing interface | âœ… HoÃ n thÃ nh |

## ðŸš€ Lá»‡nh cháº¡y project

### lab07_CartComponent (Component Library)
```bash
# Component library khÃ´ng cÃ³ build process
# Chá»‰ cáº§n import tá»« host project (lab05_ManageBuilding)

# Install dependencies náº¿u develop library
cd lab07_CartComponent
npm install

# KhÃ´ng cÃ³ dev server - library chá»‰ export components
```

### lab05_ManageBuilding (vá»›i GraphQL)

**Backend setup**:
```bash
cd lab05_ManageBuilding/backend

# Install dependencies (includes Apollo Server)
npm install

# Setup database
npm run seed

# Start server (includes GraphQL endpoint)
npm run dev

# Server runs on http://localhost:5000
# GraphQL Playground: http://localhost:5000/graphql
# REST API: http://localhost:5000/api/*
```

**Frontend setup**:
```bash
cd lab05_ManageBuilding/frontend

# Install dependencies (includes Apollo Client)
npm install

# Start Vite dev server
npm run dev

# Frontend runs on http://localhost:5173
```

**Testing GraphQL**:
```bash
# Option 1: GraphQL Playground (browser)
# Open http://localhost:5000/graphql

# Option 2: curl commands (terminal)
curl -X POST http://localhost:5000/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"query":"query { myCart { items { id code title } } }"}'

# Option 3: Apollo Client DevTools (browser extension)
# Install Apollo Client DevTools extension
# Open DevTools â†’ Apollo tab
```

## ðŸ’¡ Äiá»ƒm máº¡nh

### 1. Reusability & Modularity
- **Standalone library**: lab07_CartComponent hoÃ n toÃ n Ä‘á»™c láº­p, cÃ³ thá»ƒ reuse trong cÃ¡c projects khÃ¡c
- **Zero dependencies**: KhÃ´ng phá»¥ thuá»™c external libraries (ngoÃ i React), giáº£m bundle size
- **Plug-and-play**: Import vÃ  sá»­ dá»¥ng ngay khÃ´ng cáº§n configuration

### 2. GraphQL Advantages
- **Strongly typed**: Schema-first approach vá»›i type definitions rÃµ rÃ ng
- **Flexible queries**: Client chá»n exactly nhá»¯ng fields cáº§n thiáº¿t (no over-fetching)
- **Single endpoint**: `/graphql` thay vÃ¬ nhiá»u REST endpoints
- **Real-time updates**: Dá»… extend vá»›i subscriptions cho live cart updates
- **Interactive docs**: GraphQL Playground tá»± Ä‘á»™ng generate documentation

### 3. Authentication & Security
- **JWT in context**: Centralized authentication logic trong Apollo Server context
- **Per-resolver auth**: Má»—i resolver kiá»ƒm tra authentication independently
- **Transaction safety**: Sequelize transactions Ä‘áº£m báº£o data integrity
- **Validation layers**: Input validation + business logic validation + database constraints

### 4. Financial Accuracy
- **Price snapshots**: Store prices khi add to cart, trÃ¡nh price changes impact checkout
- **Detailed calculations**: Separate totals cho rent, buy, deposits, maintenance
- **Mode-specific logic**: Different calculations vÃ  validations cho rent vs buy

### 5. Developer Experience
- **Type safety**: GraphQL schema enforces types at API level
- **Playground**: Interactive testing khÃ´ng cáº§n Postman/curl
- **Error messages**: Descriptive errors vá»›i proper HTTP status codes
- **Code organization**: Separation of concerns (schema, resolvers, service, model)

### 6. Scalability
- **Service layer**: Business logic tÃ¡ch riÃªng, dá»… test vÃ  maintain
- **Hook pattern**: useCart hook cÃ³ thá»ƒ extend vá»›i caching, optimistic updates
- **Component composition**: Nested components (CartItemCard uses Card, Button)
- **Async operations**: All cart operations async-ready, easy to add loading states

### 7. Integration Patterns
- **Dual API support**: GraphQL cho complex queries, REST cho simple CRUD
- **Apollo Client ready**: Frontend dá»… integrate vá»›i @apollo/client
- **Backend sync**: useCart hook há»— trá»£ sync vá»›i backend API
- **Validation hooks**: Built-in apartment availability checking

---

**Tá»•ng káº¿t**: BT07 thÃ nh cÃ´ng xÃ¢y dá»±ng má»™t **reusable component library** (lab07_CartComponent) vÃ  **GraphQL API** (lab05_ManageBuilding) cho cart management system. Component library cung cáº¥p UI components vÃ  custom hooks, trong khi GraphQL API cung cáº¥p strongly-typed, flexible API vá»›i authentication, validation, vÃ  transaction safety. Integration giá»¯a hai systems táº¡o nÃªn má»™t complete solution cho apartment rental/purchase cart functionality.
